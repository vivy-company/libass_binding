// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

///
/// Regenerate bindings with `flutter pub run ffigen --config ffigen.yaml`.
///
class LibassBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  LibassBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  LibassBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// \brief Return the version of library. This returns the value LIBASS_VERSION
  /// was set to when the library was compiled.
  /// \return library version
  ///
  ///
  int ass_library_version() {
    return _ass_library_version();
  }

  late final _ass_library_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('ass_library_version');
  late final _ass_library_version =
      _ass_library_versionPtr.asFunction<int Function()>();

  /// \brief Initialize the library.
  /// \return library handle or NULL if failed
  ffi.Pointer<ASS_Library> ass_library_init() {
    return _ass_library_init();
  }

  late final _ass_library_initPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ASS_Library> Function()>>(
          'ass_library_init');
  late final _ass_library_init =
      _ass_library_initPtr.asFunction<ffi.Pointer<ASS_Library> Function()>();

  /// \brief Finalize the library
  /// \param priv library handle
  void ass_library_done(
    ffi.Pointer<ASS_Library> priv,
  ) {
    return _ass_library_done(
      priv,
    );
  }

  late final _ass_library_donePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ASS_Library>)>>(
          'ass_library_done');
  late final _ass_library_done = _ass_library_donePtr
      .asFunction<void Function(ffi.Pointer<ASS_Library>)>();

  /// \brief Set additional fonts directory.
  /// Optional directory that will be scanned for fonts.  The fonts
  /// found are used for font lookup.
  /// NOTE: A valid font directory is not needed to support embedded fonts.
  /// On Microsoft Windows, when using WIN32-APIs, fonts_dir must be in either
  /// UTF-8 mixed with lone or paired UTF-16 surrogates encoded like in CESU-8
  /// or the encoding accepted by fopen with the former taking precedence
  /// if both versions are valid and exist.
  /// On all other systems there is no need for special considerations like that.
  ///
  /// \param priv library handle
  /// \param fonts_dir directory with additional fonts
  void ass_set_fonts_dir(
    ffi.Pointer<ASS_Library> priv,
    ffi.Pointer<ffi.Char> fonts_dir,
  ) {
    return _ass_set_fonts_dir(
      priv,
      fonts_dir,
    );
  }

  late final _ass_set_fonts_dirPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ASS_Library>,
              ffi.Pointer<ffi.Char>)>>('ass_set_fonts_dir');
  late final _ass_set_fonts_dir = _ass_set_fonts_dirPtr.asFunction<
      void Function(ffi.Pointer<ASS_Library>, ffi.Pointer<ffi.Char>)>();

  /// \brief Whether fonts should be extracted from track data.
  /// \param priv library handle
  /// \param extract whether to extract fonts
  void ass_set_extract_fonts(
    ffi.Pointer<ASS_Library> priv,
    int extract,
  ) {
    return _ass_set_extract_fonts(
      priv,
      extract,
    );
  }

  late final _ass_set_extract_fontsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ASS_Library>, ffi.Int)>>('ass_set_extract_fonts');
  late final _ass_set_extract_fonts = _ass_set_extract_fontsPtr
      .asFunction<void Function(ffi.Pointer<ASS_Library>, int)>();

  /// \brief Register style overrides with a library instance.
  /// The overrides should have the form [Style.]Param=Value, e.g.
  /// SomeStyle.Font=Arial
  /// ScaledBorderAndShadow=yes
  ///
  /// \param priv library handle
  /// \param list NULL-terminated list of strings
  void ass_set_style_overrides(
    ffi.Pointer<ASS_Library> priv,
    ffi.Pointer<ffi.Pointer<ffi.Char>> list,
  ) {
    return _ass_set_style_overrides(
      priv,
      list,
    );
  }

  late final _ass_set_style_overridesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ASS_Library>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('ass_set_style_overrides');
  late final _ass_set_style_overrides = _ass_set_style_overridesPtr.asFunction<
      void Function(
          ffi.Pointer<ASS_Library>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// \brief Explicitly process style overrides for a track.
  /// \param track track handle
  void ass_process_force_style(
    ffi.Pointer<ASS_Track> track,
  ) {
    return _ass_process_force_style(
      track,
    );
  }

  late final _ass_process_force_stylePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ASS_Track>)>>(
          'ass_process_force_style');
  late final _ass_process_force_style = _ass_process_force_stylePtr
      .asFunction<void Function(ffi.Pointer<ASS_Track>)>();

  /// \brief Register a callback for debug/info messages.
  /// If a callback is registered, it is called for every message emitted by
  /// libass.  The callback receives a format string and a list of arguments,
  /// to be used for the printf family of functions. Additionally, a log level
  /// from 0 (FATAL errors) to 7 (verbose DEBUG) is passed.  Usually, level 5
  /// should be used by applications.
  /// If no callback is set, all messages level < 5 are printed to stderr,
  /// prefixed with [ass].
  ///
  /// \param priv library handle
  /// \param msg_cb pointer to callback function
  /// \param data additional data, will be passed to callback
  void ass_set_message_cb(
    ffi.Pointer<ASS_Library> priv,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>, va_list,
                    ffi.Pointer<ffi.Void>)>>
        msg_cb,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _ass_set_message_cb(
      priv,
      msg_cb,
      data,
    );
  }

  late final _ass_set_message_cbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ASS_Library>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>, va_list,
                          ffi.Pointer<ffi.Void>)>>,
              ffi.Pointer<ffi.Void>)>>('ass_set_message_cb');
  late final _ass_set_message_cb = _ass_set_message_cbPtr.asFunction<
      void Function(
          ffi.Pointer<ASS_Library>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>, va_list,
                      ffi.Pointer<ffi.Void>)>>,
          ffi.Pointer<ffi.Void>)>();

  /// \brief Initialize the renderer.
  /// \param priv library handle
  /// \return renderer handle or NULL if failed
  ///
  /// NOTE: before rendering starts the renderer should also be
  /// configured with at least ass_set_storage_size(),
  /// ass_set_frame_size() and ass_set_fonts();
  /// see respective docs.
  ffi.Pointer<ASS_Renderer> ass_renderer_init(
    ffi.Pointer<ASS_Library> arg0,
  ) {
    return _ass_renderer_init(
      arg0,
    );
  }

  late final _ass_renderer_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ASS_Renderer> Function(
              ffi.Pointer<ASS_Library>)>>('ass_renderer_init');
  late final _ass_renderer_init = _ass_renderer_initPtr.asFunction<
      ffi.Pointer<ASS_Renderer> Function(ffi.Pointer<ASS_Library>)>();

  /// \brief Finalize the renderer.
  /// \param priv renderer handle
  void ass_renderer_done(
    ffi.Pointer<ASS_Renderer> priv,
  ) {
    return _ass_renderer_done(
      priv,
    );
  }

  late final _ass_renderer_donePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ASS_Renderer>)>>(
          'ass_renderer_done');
  late final _ass_renderer_done = _ass_renderer_donePtr
      .asFunction<void Function(ffi.Pointer<ASS_Renderer>)>();

  /// \brief Set the frame size in pixels, including margins.
  /// The renderer will never return images that are outside of the frame area.
  /// The value set with this function can influence the pixel aspect ratio used
  /// for rendering.
  /// If after compensating for configured margins the frame size
  /// is not an isotropically scaled version of the video display size,
  /// you may have to use ass_set_pixel_aspect().
  /// @see ass_set_pixel_aspect()
  /// @see ass_set_margins()
  /// \param priv renderer handle
  /// \param w width
  /// \param h height
  ///
  /// NOTE: frame size must be configured before an ASS_Renderer can be used.
  void ass_set_frame_size(
    ffi.Pointer<ASS_Renderer> priv,
    int w,
    int h,
  ) {
    return _ass_set_frame_size(
      priv,
      w,
      h,
    );
  }

  late final _ass_set_frame_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ASS_Renderer>, ffi.Int,
              ffi.Int)>>('ass_set_frame_size');
  late final _ass_set_frame_size = _ass_set_frame_sizePtr
      .asFunction<void Function(ffi.Pointer<ASS_Renderer>, int, int)>();

  /// \brief Set the source image size in pixels.
  /// This affects some ASS tags like e.g. 3D transforms and
  /// is used to calculate the source aspect ratio and blur scale.
  /// The source image size can be reset to default by setting w and h to 0.
  /// The value set with this function can influence the pixel aspect ratio used
  /// for rendering.
  /// The values must be the actual storage size of the video stream,
  /// without any anamorphic de-squeeze applied.
  /// @see ass_set_pixel_aspect()
  /// \param priv renderer handle
  /// \param w width
  /// \param h height
  ///
  /// NOTE: storage size must be configured to get correct results,
  /// otherwise libass is forced to make a fallible guess.
  void ass_set_storage_size(
    ffi.Pointer<ASS_Renderer> priv,
    int w,
    int h,
  ) {
    return _ass_set_storage_size(
      priv,
      w,
      h,
    );
  }

  late final _ass_set_storage_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ASS_Renderer>, ffi.Int,
              ffi.Int)>>('ass_set_storage_size');
  late final _ass_set_storage_size = _ass_set_storage_sizePtr
      .asFunction<void Function(ffi.Pointer<ASS_Renderer>, int, int)>();

  /// \brief Set shaping level. This is merely a hint, the renderer will use
  /// whatever is available if the request cannot be fulfilled.
  /// \param level shaping level
  void ass_set_shaper(
    ffi.Pointer<ASS_Renderer> priv,
    int level,
  ) {
    return _ass_set_shaper(
      priv,
      level,
    );
  }

  late final _ass_set_shaperPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ASS_Renderer>, ffi.Int32)>>('ass_set_shaper');
  late final _ass_set_shaper = _ass_set_shaperPtr
      .asFunction<void Function(ffi.Pointer<ASS_Renderer>, int)>();

  /// \brief Set frame margins.  These values may be negative if pan-and-scan
  /// is used. The margins are in pixels. Each value specifies the distance from
  /// the video rectangle to the renderer frame. If a given margin value is
  /// positive, there will be free space between renderer frame and video area.
  /// If a given margin value is negative, the frame is inside the video, i.e.
  /// the video has been cropped.
  ///
  /// The renderer will try to keep subtitles inside the frame area. If possible,
  /// text is layout so that it is inside the cropped area. Subtitle events
  /// that can't be moved are cropped against the frame area.
  ///
  /// ass_set_use_margins() can be used to allow libass to render subtitles into
  /// the empty areas if margins are positive, i.e. the video area is smaller than
  /// the frame. (Traditionally, this has been used to show subtitles in
  /// the bottom "black bar" between video bottom screen border when playing 16:9
  /// video on a 4:3 screen.)
  ///
  /// \param priv renderer handle
  /// \param t top margin
  /// \param b bottom margin
  /// \param l left margin
  /// \param r right margin
  void ass_set_margins(
    ffi.Pointer<ASS_Renderer> priv,
    int t,
    int b,
    int l,
    int r,
  ) {
    return _ass_set_margins(
      priv,
      t,
      b,
      l,
      r,
    );
  }

  late final _ass_set_marginsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ASS_Renderer>, ffi.Int, ffi.Int,
              ffi.Int, ffi.Int)>>('ass_set_margins');
  late final _ass_set_margins = _ass_set_marginsPtr.asFunction<
      void Function(ffi.Pointer<ASS_Renderer>, int, int, int, int)>();

  /// \brief Whether margins should be used for placing regular events.
  /// \param priv renderer handle
  /// \param use whether to use the margins
  void ass_set_use_margins(
    ffi.Pointer<ASS_Renderer> priv,
    int use,
  ) {
    return _ass_set_use_margins(
      priv,
      use,
    );
  }

  late final _ass_set_use_marginsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ASS_Renderer>, ffi.Int)>>('ass_set_use_margins');
  late final _ass_set_use_margins = _ass_set_use_marginsPtr
      .asFunction<void Function(ffi.Pointer<ASS_Renderer>, int)>();

  /// \brief Set pixel aspect ratio correction.
  /// This is the ratio of pixel width to pixel height.
  ///
  /// Generally, this is (d_w / d_h) / (s_w / s_h), where s_w and s_h is the
  /// video storage size, and d_w and d_h is the video display size. (Display
  /// and storage size can be different for anamorphic video, such as DVDs.)
  ///
  /// If the pixel aspect ratio is 0, or if the aspect ratio has never been set
  /// by calling this function, libass will calculate a default pixel aspect ratio
  /// out of values set with ass_set_frame_size() and ass_set_storage_size(). Note
  /// that this default assumes the frame size after compensating for margins
  /// corresponds to an isotropically scaled version of the video display size.
  /// If the storage size has not been set, a pixel aspect ratio of 1 is assumed.
  /// \param priv renderer handle
  /// \param par pixel aspect ratio (1.0 means square pixels, 0 means default)
  void ass_set_pixel_aspect(
    ffi.Pointer<ASS_Renderer> priv,
    double par,
  ) {
    return _ass_set_pixel_aspect(
      priv,
      par,
    );
  }

  late final _ass_set_pixel_aspectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ASS_Renderer>, ffi.Double)>>('ass_set_pixel_aspect');
  late final _ass_set_pixel_aspect = _ass_set_pixel_aspectPtr
      .asFunction<void Function(ffi.Pointer<ASS_Renderer>, double)>();

  /// \brief Set aspect ratio parameters.
  /// This calls ass_set_pixel_aspect(priv, dar / sar).
  /// @deprecated New code should use ass_set_pixel_aspect().
  /// \param priv renderer handle
  /// \param dar display aspect ratio (DAR), prescaled for output PAR
  /// \param sar storage aspect ratio (SAR)
  void ass_set_aspect_ratio(
    ffi.Pointer<ASS_Renderer> priv,
    double dar,
    double sar,
  ) {
    return _ass_set_aspect_ratio(
      priv,
      dar,
      sar,
    );
  }

  late final _ass_set_aspect_ratioPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ASS_Renderer>, ffi.Double,
              ffi.Double)>>('ass_set_aspect_ratio');
  late final _ass_set_aspect_ratio = _ass_set_aspect_ratioPtr
      .asFunction<void Function(ffi.Pointer<ASS_Renderer>, double, double)>();

  /// \brief Set a fixed font scaling factor.
  /// \param priv renderer handle
  /// \param font_scale scaling factor, default is 1.0
  void ass_set_font_scale(
    ffi.Pointer<ASS_Renderer> priv,
    double font_scale,
  ) {
    return _ass_set_font_scale(
      priv,
      font_scale,
    );
  }

  late final _ass_set_font_scalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ASS_Renderer>, ffi.Double)>>('ass_set_font_scale');
  late final _ass_set_font_scale = _ass_set_font_scalePtr
      .asFunction<void Function(ffi.Pointer<ASS_Renderer>, double)>();

  /// \brief Set font hinting method.
  /// \param priv renderer handle
  /// \param ht hinting method
  void ass_set_hinting(
    ffi.Pointer<ASS_Renderer> priv,
    int ht,
  ) {
    return _ass_set_hinting(
      priv,
      ht,
    );
  }

  late final _ass_set_hintingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ASS_Renderer>, ffi.Int32)>>('ass_set_hinting');
  late final _ass_set_hinting = _ass_set_hintingPtr
      .asFunction<void Function(ffi.Pointer<ASS_Renderer>, int)>();

  /// \brief Set line spacing. Will not be scaled with frame size.
  /// \param priv renderer handle
  /// \param line_spacing line spacing in pixels
  void ass_set_line_spacing(
    ffi.Pointer<ASS_Renderer> priv,
    double line_spacing,
  ) {
    return _ass_set_line_spacing(
      priv,
      line_spacing,
    );
  }

  late final _ass_set_line_spacingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ASS_Renderer>, ffi.Double)>>('ass_set_line_spacing');
  late final _ass_set_line_spacing = _ass_set_line_spacingPtr
      .asFunction<void Function(ffi.Pointer<ASS_Renderer>, double)>();

  /// \brief Set vertical line position.
  /// \param priv renderer handle
  /// \param line_position vertical line position of subtitles in percent
  /// (0-100: 0 = on the bottom (default), 100 = on top)
  void ass_set_line_position(
    ffi.Pointer<ASS_Renderer> priv,
    double line_position,
  ) {
    return _ass_set_line_position(
      priv,
      line_position,
    );
  }

  late final _ass_set_line_positionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ASS_Renderer>, ffi.Double)>>('ass_set_line_position');
  late final _ass_set_line_position = _ass_set_line_positionPtr
      .asFunction<void Function(ffi.Pointer<ASS_Renderer>, double)>();

  /// \brief Get the list of available font providers. The output array
  /// is allocated with malloc and can be released with free(). If an
  /// allocation error occurs, size is set to (size_t)-1.
  /// \param priv library handle
  /// \param providers output, list of default providers (malloc'ed array)
  /// \param size output, number of providers
  /// \return list of available font providers (user owns the returned array)
  void ass_get_available_font_providers(
    ffi.Pointer<ASS_Library> priv,
    ffi.Pointer<ffi.Pointer<ffi.Int32>> providers,
    ffi.Pointer<ffi.Size> size,
  ) {
    return _ass_get_available_font_providers(
      priv,
      providers,
      size,
    );
  }

  late final _ass_get_available_font_providersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ASS_Library>,
              ffi.Pointer<ffi.Pointer<ffi.Int32>>,
              ffi.Pointer<ffi.Size>)>>('ass_get_available_font_providers');
  late final _ass_get_available_font_providers =
      _ass_get_available_font_providersPtr.asFunction<
          void Function(ffi.Pointer<ASS_Library>,
              ffi.Pointer<ffi.Pointer<ffi.Int32>>, ffi.Pointer<ffi.Size>)>();

  /// \brief Set font lookup defaults.
  /// \param default_font path to default font to use. Must be supplied if
  /// all system fontproviders are disabled or unavailable.
  /// \param default_family fallback font family, or NULL
  /// \param dfp which font provider to use (one of ASS_DefaultFontProvider). In
  /// older libass version, this could be 0 or 1, where 1 enabled fontconfig.
  /// Newer relases also accept 0 (ASS_FONTPROVIDER_NONE) and 1
  /// (ASS_FONTPROVIDER_AUTODETECT), which is almost backward-compatible.
  /// If the requested fontprovider does not exist or fails to initialize, the
  /// behavior is the same as when ASS_FONTPROVIDER_NONE was passed.
  /// \param config path to fontconfig configuration file, or NULL.  Only relevant
  /// if fontconfig is used. The encoding must match the one accepted by fontconfig.
  /// \param update whether fontconfig cache should be built/updated now.  Only
  /// relevant if fontconfig is used.
  ///
  /// NOTE: font lookup must be configured before an ASS_Renderer can be used.
  void ass_set_fonts(
    ffi.Pointer<ASS_Renderer> priv,
    ffi.Pointer<ffi.Char> default_font,
    ffi.Pointer<ffi.Char> default_family,
    int dfp,
    ffi.Pointer<ffi.Char> config,
    int update,
  ) {
    return _ass_set_fonts(
      priv,
      default_font,
      default_family,
      dfp,
      config,
      update,
    );
  }

  late final _ass_set_fontsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ASS_Renderer>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('ass_set_fonts');
  late final _ass_set_fonts = _ass_set_fontsPtr.asFunction<
      void Function(ffi.Pointer<ASS_Renderer>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, int)>();

  /// \brief Set selective style override mode.
  /// If enabled, the renderer attempts to override the ASS script's styling of
  /// normal subtitles, without affecting explicitly positioned text. If an event
  /// looks like a normal subtitle, parts of the font style are copied from the
  /// user style set with ass_set_selective_style_override().
  /// Warning: the heuristic used for deciding when to override the style is rather
  /// rough, and enabling this option can lead to incorrectly rendered
  /// subtitles. Since the ASS format doesn't have any support for
  /// allowing end-users to customize subtitle styling, this feature can
  /// only be implemented on "best effort" basis, and has to rely on
  /// heuristics that can easily break.
  /// \param priv renderer handle
  /// \param bits bit mask comprised of ASS_OverrideBits values.
  void ass_set_selective_style_override_enabled(
    ffi.Pointer<ASS_Renderer> priv,
    int bits,
  ) {
    return _ass_set_selective_style_override_enabled(
      priv,
      bits,
    );
  }

  late final _ass_set_selective_style_override_enabledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ASS_Renderer>,
              ffi.Int)>>('ass_set_selective_style_override_enabled');
  late final _ass_set_selective_style_override_enabled =
      _ass_set_selective_style_override_enabledPtr
          .asFunction<void Function(ffi.Pointer<ASS_Renderer>, int)>();

  /// \brief Set style for selective style override.
  /// See ass_set_selective_style_override_enabled().
  /// \param style style settings to use if override is enabled. Applications
  /// should initialize it with {0} before setting fields. Strings will be copied
  /// by the function.
  void ass_set_selective_style_override(
    ffi.Pointer<ASS_Renderer> priv,
    ffi.Pointer<ASS_Style> style,
  ) {
    return _ass_set_selective_style_override(
      priv,
      style,
    );
  }

  late final _ass_set_selective_style_overridePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ASS_Renderer>,
              ffi.Pointer<ASS_Style>)>>('ass_set_selective_style_override');
  late final _ass_set_selective_style_override =
      _ass_set_selective_style_overridePtr.asFunction<
          void Function(ffi.Pointer<ASS_Renderer>, ffi.Pointer<ASS_Style>)>();

  /// \brief This is a stub and does nothing. Old documentation: Update/build font
  /// cache.  This needs to be called if it was disabled when ass_set_fonts was set.
  ///
  /// \param priv renderer handle
  /// \return success
  int ass_fonts_update(
    ffi.Pointer<ASS_Renderer> priv,
  ) {
    return _ass_fonts_update(
      priv,
    );
  }

  late final _ass_fonts_updatePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ASS_Renderer>)>>(
          'ass_fonts_update');
  late final _ass_fonts_update = _ass_fonts_updatePtr
      .asFunction<int Function(ffi.Pointer<ASS_Renderer>)>();

  /// \brief Set hard cache limits.  Do not set, or set to zero, for reasonable
  /// defaults.
  ///
  /// \param priv renderer handle
  /// \param glyph_max maximum number of cached glyphs
  /// \param bitmap_max_size maximum bitmap cache size (in MB)
  void ass_set_cache_limits(
    ffi.Pointer<ASS_Renderer> priv,
    int glyph_max,
    int bitmap_max_size,
  ) {
    return _ass_set_cache_limits(
      priv,
      glyph_max,
      bitmap_max_size,
    );
  }

  late final _ass_set_cache_limitsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ASS_Renderer>, ffi.Int,
              ffi.Int)>>('ass_set_cache_limits');
  late final _ass_set_cache_limits = _ass_set_cache_limitsPtr
      .asFunction<void Function(ffi.Pointer<ASS_Renderer>, int, int)>();

  /// \brief Render a frame, producing a list of ASS_Image.
  /// \param priv renderer handle
  /// \param track subtitle track
  /// \param now video timestamp in milliseconds
  /// \param detect_change compare to the previous call and set to 1
  /// if positions may have changed, or set to 2 if content may have changed.
  ffi.Pointer<ASS_Image> ass_render_frame(
    ffi.Pointer<ASS_Renderer> priv,
    ffi.Pointer<ASS_Track> track,
    int now,
    ffi.Pointer<ffi.Int> detect_change,
  ) {
    return _ass_render_frame(
      priv,
      track,
      now,
      detect_change,
    );
  }

  late final _ass_render_framePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ASS_Image> Function(
              ffi.Pointer<ASS_Renderer>,
              ffi.Pointer<ASS_Track>,
              ffi.LongLong,
              ffi.Pointer<ffi.Int>)>>('ass_render_frame');
  late final _ass_render_frame = _ass_render_framePtr.asFunction<
      ffi.Pointer<ASS_Image> Function(ffi.Pointer<ASS_Renderer>,
          ffi.Pointer<ASS_Track>, int, ffi.Pointer<ffi.Int>)>();

  /// \brief Allocate a new empty track object.
  /// \param library handle
  /// \return pointer to empty track or NULL on failure
  ffi.Pointer<ASS_Track> ass_new_track(
    ffi.Pointer<ASS_Library> arg0,
  ) {
    return _ass_new_track(
      arg0,
    );
  }

  late final _ass_new_trackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ASS_Track> Function(
              ffi.Pointer<ASS_Library>)>>('ass_new_track');
  late final _ass_new_track = _ass_new_trackPtr
      .asFunction<ffi.Pointer<ASS_Track> Function(ffi.Pointer<ASS_Library>)>();

  /// \brief Enable or disable certain features
  /// This manages flags that control the behavior of the renderer and how certain
  /// tags etc. within the track are interpreted. The defaults on a newly created
  /// ASS_Track are such that rendering is compatible with traditional renderers
  /// like VSFilter, and/or old versions of libass. Calling ass_process_data() or
  /// ass_process_codec_private() may change some of these flags according to file
  /// headers. (ass_process_chunk() will not change any of the flags.)
  /// Additions to ASS_Feature are backward compatible to old libass releases (ABI
  /// compatibility).
  /// After calling ass_render_frame, changing features is no longer allowed.
  /// \param track track
  /// \param feature the specific feature to enable or disable
  /// \param enable 0 for disable, any non-0 value for enable
  /// \return 0 if feature set, -1 if feature is unknown
  int ass_track_set_feature(
    ffi.Pointer<ASS_Track> track,
    int feature,
    int enable,
  ) {
    return _ass_track_set_feature(
      track,
      feature,
      enable,
    );
  }

  late final _ass_track_set_featurePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ASS_Track>, ffi.Int32,
              ffi.Int)>>('ass_track_set_feature');
  late final _ass_track_set_feature = _ass_track_set_featurePtr
      .asFunction<int Function(ffi.Pointer<ASS_Track>, int, int)>();

  /// \brief Deallocate track and all its child objects (styles and events).
  /// \param track track to deallocate or NULL
  void ass_free_track(
    ffi.Pointer<ASS_Track> track,
  ) {
    return _ass_free_track(
      track,
    );
  }

  late final _ass_free_trackPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ASS_Track>)>>(
          'ass_free_track');
  late final _ass_free_track =
      _ass_free_trackPtr.asFunction<void Function(ffi.Pointer<ASS_Track>)>();

  /// \brief Allocate new style.
  /// \param track track
  /// \return newly allocated style id >= 0, or a value < 0 on failure
  /// See GENERAL NOTE in ass_types.h.
  int ass_alloc_style(
    ffi.Pointer<ASS_Track> track,
  ) {
    return _ass_alloc_style(
      track,
    );
  }

  late final _ass_alloc_stylePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ASS_Track>)>>(
          'ass_alloc_style');
  late final _ass_alloc_style =
      _ass_alloc_stylePtr.asFunction<int Function(ffi.Pointer<ASS_Track>)>();

  /// \brief Allocate new event.
  /// \param track track
  /// \return newly allocated event id >= 0, or a value < 0 on failure
  /// See GENERAL NOTE in ass_types.h.
  int ass_alloc_event(
    ffi.Pointer<ASS_Track> track,
  ) {
    return _ass_alloc_event(
      track,
    );
  }

  late final _ass_alloc_eventPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ASS_Track>)>>(
          'ass_alloc_event');
  late final _ass_alloc_event =
      _ass_alloc_eventPtr.asFunction<int Function(ffi.Pointer<ASS_Track>)>();

  /// \brief Delete a style.
  /// \param track track
  /// \param sid style id
  /// Deallocates style data. Does not modify track->n_styles.
  /// Freeing a style without subsequently setting track->n_styles
  /// to a value less than or equal to the freed style id before calling
  /// any other libass API function on the track is undefined behaviour.
  /// Additionally a freed style style still being referenced by an event
  /// in track->events will also result in undefined behaviour.
  /// See GENERAL NOTE in ass_types.h.
  void ass_free_style(
    ffi.Pointer<ASS_Track> track,
    int sid,
  ) {
    return _ass_free_style(
      track,
      sid,
    );
  }

  late final _ass_free_stylePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ASS_Track>, ffi.Int)>>('ass_free_style');
  late final _ass_free_style = _ass_free_stylePtr
      .asFunction<void Function(ffi.Pointer<ASS_Track>, int)>();

  /// \brief Delete an event.
  /// \param track track
  /// \param eid event id
  /// Deallocates event data. Does not modify track->n_events.
  /// Freeing an event without subsequently setting track->n_events
  /// to a value less than or equal to the freed event id before calling
  /// any other libass API function on the track is undefined behaviour.
  /// See GENERAL NOTE in ass_types.h
  void ass_free_event(
    ffi.Pointer<ASS_Track> track,
    int eid,
  ) {
    return _ass_free_event(
      track,
      eid,
    );
  }

  late final _ass_free_eventPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ASS_Track>, ffi.Int)>>('ass_free_event');
  late final _ass_free_event = _ass_free_eventPtr
      .asFunction<void Function(ffi.Pointer<ASS_Track>, int)>();

  /// \brief Parse a chunk of subtitle stream data.
  /// \param track track
  /// \param data string to parse
  /// \param size length of data
  void ass_process_data(
    ffi.Pointer<ASS_Track> track,
    ffi.Pointer<ffi.Char> data,
    int size,
  ) {
    return _ass_process_data(
      track,
      data,
      size,
    );
  }

  late final _ass_process_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ASS_Track>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('ass_process_data');
  late final _ass_process_data = _ass_process_dataPtr.asFunction<
      void Function(ffi.Pointer<ASS_Track>, ffi.Pointer<ffi.Char>, int)>();

  /// \brief Parse Codec Private section of the subtitle stream, in Matroska
  /// format.  See the Matroska specification for details.
  /// \param track target track
  /// \param data string to parse
  /// \param size length of data
  void ass_process_codec_private(
    ffi.Pointer<ASS_Track> track,
    ffi.Pointer<ffi.Char> data,
    int size,
  ) {
    return _ass_process_codec_private(
      track,
      data,
      size,
    );
  }

  late final _ass_process_codec_privatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ASS_Track>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('ass_process_codec_private');
  late final _ass_process_codec_private =
      _ass_process_codec_privatePtr.asFunction<
          void Function(ffi.Pointer<ASS_Track>, ffi.Pointer<ffi.Char>, int)>();

  /// \brief Parse a chunk of subtitle stream data. A chunk contains exactly one
  /// event in Matroska format.  See the Matroska specification for details.
  /// In later libass versions (since LIBASS_VERSION==0x01300001), using this
  /// function means you agree not to modify events manually, or using other
  /// functions manipulating the event list like ass_process_data(). If you do
  /// anyway, the internal duplicate checking might break. Calling
  /// ass_flush_events() is still allowed.
  /// \param track track
  /// \param data string to parse
  /// \param size length of data
  /// \param timecode starting time of the event (milliseconds)
  /// \param duration duration of the event (milliseconds)
  void ass_process_chunk(
    ffi.Pointer<ASS_Track> track,
    ffi.Pointer<ffi.Char> data,
    int size,
    int timecode,
    int duration,
  ) {
    return _ass_process_chunk(
      track,
      data,
      size,
      timecode,
      duration,
    );
  }

  late final _ass_process_chunkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ASS_Track>, ffi.Pointer<ffi.Char>,
              ffi.Int, ffi.LongLong, ffi.LongLong)>>('ass_process_chunk');
  late final _ass_process_chunk = _ass_process_chunkPtr.asFunction<
      void Function(
          ffi.Pointer<ASS_Track>, ffi.Pointer<ffi.Char>, int, int, int)>();

  /// \brief Set whether the ReadOrder field when processing a packet with
  /// ass_process_chunk() should be used for eliminating duplicates.
  /// \param check_readorder 0 means do not try to eliminate duplicates; 1 means
  /// use the ReadOrder field embedded in the packet as unique identifier, and
  /// discard the packet if there was already a packet with the same ReadOrder.
  /// Other values are undefined.
  /// If this function is not called, the default value is 1.
  void ass_set_check_readorder(
    ffi.Pointer<ASS_Track> track,
    int check_readorder,
  ) {
    return _ass_set_check_readorder(
      track,
      check_readorder,
    );
  }

  late final _ass_set_check_readorderPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ASS_Track>, ffi.Int)>>('ass_set_check_readorder');
  late final _ass_set_check_readorder = _ass_set_check_readorderPtr
      .asFunction<void Function(ffi.Pointer<ASS_Track>, int)>();

  /// \brief Flush buffered events.
  /// \param track track
  void ass_flush_events(
    ffi.Pointer<ASS_Track> track,
  ) {
    return _ass_flush_events(
      track,
    );
  }

  late final _ass_flush_eventsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ASS_Track>)>>(
          'ass_flush_events');
  late final _ass_flush_events =
      _ass_flush_eventsPtr.asFunction<void Function(ffi.Pointer<ASS_Track>)>();

  /// \brief Read subtitles from file.
  /// \param library library handle
  /// \param fname file name
  /// \param codepage encoding (iconv format)
  /// \return newly allocated track or NULL on failure
  /// NOTE: On Microsoft Windows, when using WIN32-APIs, fname must be in either
  /// UTF-8 mixed with lone or paired UTF-16 surrogates encoded like in CESU-8
  /// or the encoding accepted by fopen with the former taking precedence
  /// if both versions are valid and exist.
  /// On all other systems there is no need for special considerations like that.
  ffi.Pointer<ASS_Track> ass_read_file(
    ffi.Pointer<ASS_Library> library1,
    ffi.Pointer<ffi.Char> fname,
    ffi.Pointer<ffi.Char> codepage,
  ) {
    return _ass_read_file(
      library1,
      fname,
      codepage,
    );
  }

  late final _ass_read_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ASS_Track> Function(ffi.Pointer<ASS_Library>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('ass_read_file');
  late final _ass_read_file = _ass_read_filePtr.asFunction<
      ffi.Pointer<ASS_Track> Function(ffi.Pointer<ASS_Library>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// \brief Read subtitles from memory.
  /// \param library library handle
  /// \param buf pointer to subtitles text
  /// \param bufsize size of buffer
  /// \param codepage encoding (iconv format)
  /// \return newly allocated track or NULL on failure
  ffi.Pointer<ASS_Track> ass_read_memory(
    ffi.Pointer<ASS_Library> library1,
    ffi.Pointer<ffi.Char> buf,
    int bufsize,
    ffi.Pointer<ffi.Char> codepage,
  ) {
    return _ass_read_memory(
      library1,
      buf,
      bufsize,
      codepage,
    );
  }

  late final _ass_read_memoryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ASS_Track> Function(
              ffi.Pointer<ASS_Library>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Char>)>>('ass_read_memory');
  late final _ass_read_memory = _ass_read_memoryPtr.asFunction<
      ffi.Pointer<ASS_Track> Function(ffi.Pointer<ASS_Library>,
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  /// \brief Read styles from file into already initialized track.
  /// \param fname file name
  /// \param codepage encoding (iconv format)
  /// \return 0 on success
  /// NOTE: On Microsoft Windows, when using WIN32-APIs, fname must be in either
  /// UTF-8 mixed with lone or paired UTF-16 surrogates encoded like in CESU-8
  /// or the encoding accepted by fopen with the former taking precedence
  /// if both versions are valid and exist.
  /// On all other systems there is no need for special considerations like that.
  int ass_read_styles(
    ffi.Pointer<ASS_Track> track,
    ffi.Pointer<ffi.Char> fname,
    ffi.Pointer<ffi.Char> codepage,
  ) {
    return _ass_read_styles(
      track,
      fname,
      codepage,
    );
  }

  late final _ass_read_stylesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ASS_Track>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('ass_read_styles');
  late final _ass_read_styles = _ass_read_stylesPtr.asFunction<
      int Function(ffi.Pointer<ASS_Track>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// \brief Add a memory font.
  /// \param library library handle
  /// \param name attachment name
  /// \param data binary font data
  /// \param data_size data size
  void ass_add_font(
    ffi.Pointer<ASS_Library> library1,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> data,
    int data_size,
  ) {
    return _ass_add_font(
      library1,
      name,
      data,
      data_size,
    );
  }

  late final _ass_add_fontPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ASS_Library>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('ass_add_font');
  late final _ass_add_font = _ass_add_fontPtr.asFunction<
      void Function(ffi.Pointer<ASS_Library>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, int)>();

  /// \brief Remove all fonts stored in an ass_library object.
  /// This can only be called safely if all ASS_Track and ASS_Renderer instances
  /// associated with the library handle have been released first.
  /// \param library library handle
  void ass_clear_fonts(
    ffi.Pointer<ASS_Library> library1,
  ) {
    return _ass_clear_fonts(
      library1,
    );
  }

  late final _ass_clear_fontsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ASS_Library>)>>(
          'ass_clear_fonts');
  late final _ass_clear_fonts =
      _ass_clear_fontsPtr.asFunction<void Function(ffi.Pointer<ASS_Library>)>();

  /// \brief Calculates timeshift from now to the start of some other subtitle
  /// event, depending on movement parameter.
  /// \param track subtitle track
  /// \param now current time in milliseconds
  /// \param movement how many events to skip from the one currently displayed
  /// +2 means "the one after the next", -1 means "previous"
  /// \return timeshift in milliseconds
  int ass_step_sub(
    ffi.Pointer<ASS_Track> track,
    int now,
    int movement,
  ) {
    return _ass_step_sub(
      track,
      now,
      movement,
    );
  }

  late final _ass_step_subPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(
              ffi.Pointer<ASS_Track>, ffi.LongLong, ffi.Int)>>('ass_step_sub');
  late final _ass_step_sub = _ass_step_subPtr
      .asFunction<int Function(ffi.Pointer<ASS_Track>, int, int)>();
}

/// A linked list of images produced by an ass renderer.
///
/// These images have to be rendered in-order for the correct screen
/// composition.  The libass renderer clips these bitmaps to the frame size.
/// w/h can be zero, in this case the bitmap should not be rendered at all.
/// The last bitmap row is not guaranteed to be padded up to stride size,
/// e.g. in the worst case a bitmap has the size stride * (h - 1) + w.
class ass_image extends ffi.Struct {
  /// Bitmap width/height
  @ffi.Int()
  external int w;

  @ffi.Int()
  external int h;

  /// Bitmap stride
  @ffi.Int()
  external int stride;

  /// 1bpp stride*h alpha buffer
  /// Note: the last row may not be padded to
  /// bitmap stride!
  external ffi.Pointer<ffi.UnsignedChar> bitmap;

  /// Bitmap color and alpha, RGBA
  /// For full VSFilter compatibility, the value
  /// must be transformed as described in
  /// ass_types.h for ASS_YCbCrMatrix
  @ffi.Uint32()
  external int color;

  /// Bitmap placement inside the video frame
  @ffi.Int()
  external int dst_x;

  @ffi.Int()
  external int dst_y;

  /// Next image, or NULL
  external ffi.Pointer<ass_image> next;

  @ffi.Int32()
  external int type;
}

/// Hinting type. (see ass_set_hinting below)
///
/// Setting hinting to anything but ASS_HINTING_NONE will put libass in a mode
/// that reduces compatibility with vsfilter and many ASS scripts. The main
/// problem is that hinting conflicts with smooth scaling, which precludes
/// animations and precise positioning.
///
/// In other words, enabling hinting might break some scripts severely.
///
/// FreeType's native hinter is still buggy sometimes and it is recommended
/// to use the light autohinter, ASS_HINTING_LIGHT, instead.  For best
/// compatibility with problematic fonts, disable hinting.
abstract class ASS_Hinting {
  static const int ASS_HINTING_NONE = 0;
  static const int ASS_HINTING_LIGHT = 1;
  static const int ASS_HINTING_NORMAL = 2;
  static const int ASS_HINTING_NATIVE = 3;
}

/// \brief Text shaping levels.
///
/// SIMPLE is a fast, font-agnostic shaper that can do only substitutions.
/// COMPLEX is a slower shaper using OpenType for substitutions and positioning.
///
/// libass uses the best shaper available by default.
abstract class ASS_ShapingLevel {
  static const int ASS_SHAPING_SIMPLE = 0;
  static const int ASS_SHAPING_COMPLEX = 1;
}

/// \brief Style override options. See
/// ass_set_selective_style_override_enabled() for details.
abstract class ASS_OverrideBits {
  /// Default mode (with no other bits set). All selective override features
  /// as well as the style set with ass_set_selective_style_override() are
  /// disabled, but traditional overrides like ass_set_font_scale() are
  /// applied unconditionally.
  static const int ASS_OVERRIDE_DEFAULT = 0;

  /// Apply the style as set with ass_set_selective_style_override() on events
  /// which look like dialogue. Other style overrides are also applied this
  /// way, except ass_set_font_scale(). How ass_set_font_scale() is applied
  /// depends on the ASS_OVERRIDE_BIT_SELECTIVE_FONT_SCALE flag.
  ///
  /// This is equivalent to setting all of the following bits:
  ///
  /// ASS_OVERRIDE_BIT_FONT_NAME
  /// ASS_OVERRIDE_BIT_FONT_SIZE_FIELDS
  /// ASS_OVERRIDE_BIT_COLORS
  /// ASS_OVERRIDE_BIT_BORDER
  /// ASS_OVERRIDE_BIT_ATTRIBUTES
  static const int ASS_OVERRIDE_BIT_STYLE = 1;

  /// Apply ass_set_font_scale() only on events which look like dialogue.
  /// If not set, the font scale is applied to all events. (The behavior and
  /// name of this flag are unintuitive, but exist for compatibility)
  static const int ASS_OVERRIDE_BIT_SELECTIVE_FONT_SCALE = 2;

  /// Old alias for ASS_OVERRIDE_BIT_SELECTIVE_FONT_SCALE. Deprecated. Do not use.
  static const int ASS_OVERRIDE_BIT_FONT_SIZE = 2;

  /// On dialogue events override: FontSize, Spacing, Blur, ScaleX, ScaleY
  static const int ASS_OVERRIDE_BIT_FONT_SIZE_FIELDS = 4;

  /// On dialogue events override: FontName, treat_fontname_as_pattern
  static const int ASS_OVERRIDE_BIT_FONT_NAME = 8;

  /// On dialogue events override: PrimaryColour, SecondaryColour, OutlineColour, BackColour
  static const int ASS_OVERRIDE_BIT_COLORS = 16;

  /// On dialogue events override: Bold, Italic, Underline, StrikeOut
  static const int ASS_OVERRIDE_BIT_ATTRIBUTES = 32;

  /// On dialogue events override: BorderStyle, Outline, Shadow
  static const int ASS_OVERRIDE_BIT_BORDER = 64;

  /// On dialogue events override: Alignment
  static const int ASS_OVERRIDE_BIT_ALIGNMENT = 128;

  /// On dialogue events override: MarginL, MarginR, MarginV
  static const int ASS_OVERRIDE_BIT_MARGINS = 256;

  /// Unconditionally replace all fields of all styles with the one provided
  /// with ass_set_selective_style_override().
  /// Does not apply ASS_OVERRIDE_BIT_SELECTIVE_FONT_SCALE.
  /// Add ASS_OVERRIDE_BIT_FONT_SIZE_FIELDS and ASS_OVERRIDE_BIT_BORDER if
  /// you want FontSize, Spacing, Outline, Shadow to be scaled to the script
  /// resolution given by the ASS_Track.
  static const int ASS_OVERRIDE_FULL_STYLE = 512;

  /// On dialogue events override: Justify
  static const int ASS_OVERRIDE_BIT_JUSTIFY = 1024;
}

/// \brief Default Font provider to load fonts in libass' database
///
/// NONE don't use any default font provider for font lookup
/// AUTODETECT use the first available font provider
/// CORETEXT force a CoreText based font provider (OS X only)
/// DIRECTWRITE force a DirectWrite based font provider (Microsoft Win32 only)
/// FONTCONFIG force a Fontconfig based font provider
///
/// libass uses the best shaper available by default.
abstract class ASS_DefaultFontProvider {
  static const int ASS_FONTPROVIDER_NONE = 0;
  static const int ASS_FONTPROVIDER_AUTODETECT = 1;
  static const int ASS_FONTPROVIDER_CORETEXT = 2;
  static const int ASS_FONTPROVIDER_FONTCONFIG = 3;
  static const int ASS_FONTPROVIDER_DIRECTWRITE = 4;
}

abstract class ASS_Feature {
  /// Enable libass extensions that would display ASS subtitles incorrectly.
  /// These may be useful for applications, which use libass as renderer for
  /// subtitles converted from another format, or which use libass for other
  /// purposes that do not involve actual ASS subtitles authored for
  /// distribution.
  static const int ASS_FEATURE_INCOMPATIBLE_EXTENSIONS = 0;

  /// Match bracket pairs in bidirectional text according to the revised
  /// Unicode Bidirectional Algorithm introduced in Unicode 6.3.
  /// This is incompatible with VSFilter and disabled by default.
  ///
  /// (Directional isolates, also introduced in Unicode 6.3,
  /// are unconditionally processed when FriBidi is new enough.)
  ///
  /// This feature may be unavailable at runtime (ass_track_set_feature
  /// may return -1) if libass was compiled against old FriBidi.
  static const int ASS_FEATURE_BIDI_BRACKETS = 1;

  /// When this feature is disabled, text is split into VSFilter-compatible
  /// segments and text in each segment is processed in isolation.
  /// Notably, this includes running the Unicode Bidirectional
  /// Algorithm and shaping the text within each run separately.
  /// The individual runs are then laid out left-to-right,
  /// even if they contain right-to-left text.
  ///
  /// When this feature is enabled, each event's text is processed as a whole
  /// (as far as possible). In particular, the Unicode Bidirectional
  /// Algorithm is run on the whole text, and text is shaped across
  /// override tags.
  ///
  /// This is incompatible with VSFilter and disabled by default.
  ///
  /// libass extensions to ASS such as Encoding -1 can cause individual
  /// events to be always processed as if this feature is enabled.
  static const int ASS_FEATURE_WHOLE_TEXT_LAYOUT = 2;

  /// Break lines according to the Unicode Line Breaking Algorithm.
  /// If the track language is set, some additional language-specific tweaks
  /// may be applied. Setting this enables more breaking opportunities
  /// compared to classic ASS. However, it is still possible for long words
  /// without breaking opportunities to cause overfull lines.
  /// This is incompatible with VSFilter and disabled by default.
  ///
  /// This feature may be unavailable at runtime if
  /// libass was compiled without libunibreak support.
  static const int ASS_FEATURE_WRAP_UNICODE = 3;
}

typedef ASS_Library = ass_library;

class ass_library extends ffi.Opaque {}

/// ass track represent either an external script or a matroska subtitle stream
/// (no real difference between them); it can be used in rendering after the
/// headers are parsed (i.e. events format line read).
typedef ASS_Track = ass_track;

/// ass track represent either an external script or a matroska subtitle stream
/// (no real difference between them); it can be used in rendering after the
/// headers are parsed (i.e. events format line read).
class ass_track extends ffi.Struct {
  /// amount used
  @ffi.Int()
  external int n_styles;

  /// amount allocated
  @ffi.Int()
  external int max_styles;

  @ffi.Int()
  external int n_events;

  @ffi.Int()
  external int max_events;

  /// array of styles, max_styles length, n_styles used
  external ffi.Pointer<ASS_Style> styles;

  /// the same as styles
  external ffi.Pointer<ASS_Event> events;

  /// style format line (everything after "Format: ")
  external ffi.Pointer<ffi.Char> style_format;

  /// event format line
  external ffi.Pointer<ffi.Char> event_format;

  @ffi.Int32()
  external int track_type;

  /// Script header fields
  @ffi.Int()
  external int PlayResX;

  @ffi.Int()
  external int PlayResY;

  @ffi.Double()
  external double Timer;

  @ffi.Int()
  external int WrapStyle;

  /// 0 or 1 (boolean)
  @ffi.Int()
  external int ScaledBorderAndShadow;

  /// 0 or 1 (boolean)
  @ffi.Int()
  external int Kerning;

  /// zero-terminated ISO-639-1 code
  external ffi.Pointer<ffi.Char> Language;

  @ffi.Int32()
  external int YCbCrMatrix;

  /// index of default style
  @ffi.Int()
  external int default_style;

  /// file name in case of external subs, 0 for streams
  external ffi.Pointer<ffi.Char> name;

  external ffi.Pointer<ASS_Library> library1;

  external ffi.Pointer<ASS_ParserPriv> parser_priv;
}

/// ASS Style: line
typedef ASS_Style = ass_style;

/// ASS Style: line
class ass_style extends ffi.Struct {
  /// must be a valid non-NULL string pointer; may be an empty string
  external ffi.Pointer<ffi.Char> Name;

  /// must be a valid non-NULL string pointer; may be an empty string
  external ffi.Pointer<ffi.Char> FontName;

  @ffi.Double()
  external double FontSize;

  @ffi.Uint32()
  external int PrimaryColour;

  @ffi.Uint32()
  external int SecondaryColour;

  @ffi.Uint32()
  external int OutlineColour;

  @ffi.Uint32()
  external int BackColour;

  /// 0 or 1 (boolean)
  @ffi.Int()
  external int Bold;

  /// 0 or 1 (boolean)
  @ffi.Int()
  external int Italic;

  /// 0 or 1 (boolean)
  @ffi.Int()
  external int Underline;

  /// 0 or 1 (boolean)
  @ffi.Int()
  external int StrikeOut;

  /// positive with 1.0 representing 100%
  @ffi.Double()
  external double ScaleX;

  /// positive with 1.0 representing 100%
  @ffi.Double()
  external double ScaleY;

  @ffi.Double()
  external double Spacing;

  @ffi.Double()
  external double Angle;

  @ffi.Int()
  external int BorderStyle;

  @ffi.Double()
  external double Outline;

  @ffi.Double()
  external double Shadow;

  /// use `VALIGN_* | HALIGN_*` as value
  @ffi.Int()
  external int Alignment;

  @ffi.Int()
  external int MarginL;

  @ffi.Int()
  external int MarginR;

  @ffi.Int()
  external int MarginV;

  @ffi.Int()
  external int Encoding;

  /// does nothing (left in place for ABI-compatibility)
  @ffi.Int()
  external int treat_fontname_as_pattern;

  /// sets a default \blur for the event; same values as \blur
  @ffi.Double()
  external double Blur;

  /// sets text justification independent of event alignment; use ASS_JUSTIFY_*
  @ffi.Int()
  external int Justify;
}

/// ASS_Event corresponds to a single Dialogue line;
/// text is stored as-is, style overrides will be parsed later.
typedef ASS_Event = ass_event;

/// ASS_Event corresponds to a single Dialogue line;
/// text is stored as-is, style overrides will be parsed later.
class ass_event extends ffi.Struct {
  /// ms
  @ffi.LongLong()
  external int Start;

  /// ms
  @ffi.LongLong()
  external int Duration;

  @ffi.Int()
  external int ReadOrder;

  @ffi.Int()
  external int Layer;

  @ffi.Int()
  external int Style;

  external ffi.Pointer<ffi.Char> Name;

  @ffi.Int()
  external int MarginL;

  @ffi.Int()
  external int MarginR;

  @ffi.Int()
  external int MarginV;

  external ffi.Pointer<ffi.Char> Effect;

  external ffi.Pointer<ffi.Char> Text;

  external ffi.Pointer<ASS_RenderPriv> render_priv;
}

typedef ASS_RenderPriv = render_priv;

class render_priv extends ffi.Opaque {}

/// Support for (xy-)VSFilter mangled colors
///
/// Generally, xy-VSFilter emulates the classic VSFilter behavior of
/// rendering directly into the (usually YCbCr) video. Classic
/// guliverkli(2)-VSFilter is hardcoded to use BT.601(TV) as target colorspace
/// when converting the subtitle RGB color to the video colorspace.
/// This led to odd results when other colorspaces were used, particular
/// once those became more common with the rise of HDTV video:
/// HDTV typically uses BT.709(TV), but VSFilter continued assuming
/// BT.601(TV) for conversion.
///
/// This means classic vsfilter will mangle colors as follows:
///
/// screen_rgb = video_csp_to_rgb(rgb_to_bt601tv(ass_rgb))
///
/// where video_csp is the colorspace of the video with which the
/// subtitle was muxed.
///
/// Subtitle authors worked around this issue by adjusting the color
/// to look as intended *after* going through the mangling process. Still,
/// this behaviour isn't great and also limits the color range. Yet,
/// for backwards compatibility with existing files, the classic mangling
/// must be preserved for existing files to not break the display of
/// color-matched typesets created with older VSFilter versions. Thus,
/// on iniative of xy-VSFilter/XYSubFilter a new explicit "YCbCr Matrix"
/// header was introduced to allow new files to avoid this color mangling.
/// However due to a limitation of VSFilter API, VSFilters don't actually
/// know the real colorspace of the video they're rendering to, so the
/// header wasn't created as a simple "Use ColourMangling: yes/no", but instead
/// specifies exactly which colorspace to use for the initial conversion
/// from the subtitle's RGB values. So we now got
///
/// screen_rgb = video_csp_to_rgb(rgb_to_ycbcr_header_csp(ass_rgb))
///
/// with rgb_to_ycbcr_header_csp defaulting to TV-range BT.601.
///
/// XySubFilter, whose API was planned during introduction of this header,
/// is not affected by this VSFilter-API limitation, so for it and other
/// renderers like libass an additional special value "None" was also added.
/// "None" tells the renderer to directly use untouched RGB values without
/// any conversion.
/// The above mangling process with special value "None" to opt out
/// of any colour mangling is the recommended default behaviour.
///
/// Keep in mind though, that xy-VSFilter cannot accurately implement this and
/// will instead resort to a guessing the video colorspace based on resolution
/// and then convert RGB to the guessed space.
/// Also some versions of MPC-HC's Internal Subtitle Renderer don't (explicitly)
/// implement "None", but use xy-VSFilter-like resolution-based guessing for
/// unknown values or no header at all (which ofc also breaks old subtitles).
///
/// Aegisub's (the main application to produce ASS subtitle scripts) behaviour
/// regarding colorspaces is unfortunately a bit confusing.
/// As of time of writing there still is a config option to force BT.601(TV)
/// in some active forks (which should not be used to author subs and serves
/// at most as a tool to check how now ancient VSFilters would have rendered the
/// subs), the automatically chosen colorspace may depend on the fork and the
/// videoprovider used and furthermore Aegisub likes to override
/// "YCbCr Matrix: None" with the autodetected space of a loaded video.
/// Supposedly some Aegisub versions had an option that "tries not to mangle the
/// colors". It was said that if the header is not set to BT.601(TV), the colors
/// were supposed not to be mangled, even if the header was not set to "None".
///
/// In general, misinterpreting this header or not using it will lead to
/// slightly different subtitle colors, which can matter if the subtitle
/// attempts to match solid colored areas in the video.
/// It is recommended to stick to XySubFilter-like behaviour described above.
/// A highly motivated application may also expose options to users to  emulate
/// xy-VSFilter's resolution-depended guess or other (historic) mangling modes.
/// Completly ignoring the color mangling is likely to give bad results.
///
/// Note that libass doesn't change colors based on this header. It
/// absolutely can't do that, because the video colorspace is required
/// in order to handle this as intended. API users must use the exposed
/// information to perform color mangling as described above.
abstract class ASS_YCbCrMatrix {
  /// Header missing
  static const int YCBCR_DEFAULT = 0;

  /// Header could not be parsed correctly
  static const int YCBCR_UNKNOWN = 1;

  /// "None" special value
  static const int YCBCR_NONE = 2;
  static const int YCBCR_BT601_TV = 3;
  static const int YCBCR_BT601_PC = 4;
  static const int YCBCR_BT709_TV = 5;
  static const int YCBCR_BT709_PC = 6;
  static const int YCBCR_SMPTE240M_TV = 7;
  static const int YCBCR_SMPTE240M_PC = 8;
  static const int YCBCR_FCC_TV = 9;
  static const int YCBCR_FCC_PC = 10;
}

typedef ASS_ParserPriv = parser_priv;

class parser_priv extends ffi.Opaque {}

typedef va_list = __builtin_va_list;
typedef __builtin_va_list = ffi.Pointer<ffi.Char>;

/// Opaque objects internally used by libass.  Contents are private.
typedef ASS_Renderer = ass_renderer;

class ass_renderer extends ffi.Opaque {}

/// A linked list of images produced by an ass renderer.
///
/// These images have to be rendered in-order for the correct screen
/// composition.  The libass renderer clips these bitmaps to the frame size.
/// w/h can be zero, in this case the bitmap should not be rendered at all.
/// The last bitmap row is not guaranteed to be padded up to stride size,
/// e.g. in the worst case a bitmap has the size stride * (h - 1) + w.
typedef ASS_Image = ass_image;

const int IMAGE_TYPE_CHARACTER = 0;

const int IMAGE_TYPE_OUTLINE = 1;

const int IMAGE_TYPE_SHADOW = 2;

const int TRACK_TYPE_UNKNOWN = 0;

const int TRACK_TYPE_ASS = 1;

const int TRACK_TYPE_SSA = 2;

const int LIBASS_VERSION = 23068688;
